<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 第一个分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 666 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计思想和原则</title>
      <link href="/post/f016668f.html"/>
      <url>/post/f016668f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计思想和原则"><a href="#设计思想和原则" class="headerlink" title="设计思想和原则"></a>设计思想和原则</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="对接口编程而不是对实现编程"><a href="#对接口编程而不是对实现编程" class="headerlink" title="对接口编程而不是对实现编程"></a>对接口编程而不是对实现编程</h3><p>接口位于上层（抽象层），面向接口编程而不是面向实现编程，可以将接口和实现分离，封装不稳定的实现，暴露稳定的接口，这样当实现类发生变化时，上游的代码基本上不需要改动，以此来降低耦合性。</p><blockquote><p>因为我们依赖的实现类可能需要经常变化</p></blockquote><ol><li><p>如果某个功能有多种实现方式，我们应该把他们抽象出来，通过接口实现或者抽象类的方式继承（例如上传图片到阿里云/私有云，这里就有多种方式，此时应该抽离出一个ImageStore存储的接口，让阿里云和私有云都实现这个接口，然后我们使用调用接口的方法）</p></li><li><p>有了接口，上层直接调用接口，我们底层实现类可以随意更换，而不会影响上层的代码（例如service中注入dao接口，而dao接口实现类我们可以通过Mybatis或者hibernate（任意一个实现dao接口的实现类）操作数据库，我们都不需要修改service中的代码）</p></li></ol><h3 id="多用组合少用继承"><a href="#多用组合少用继承" class="headerlink" title="多用组合少用继承"></a>多用组合少用继承</h3><p>继承的缺点：</p><ol><li><p>当我们在父类进行修改，对下面的子类都会产生影响（例如鸟要添加fly方法，可能子类鸵鸟等不具备。会出现很多问题）</p></li><li><p>java继承只能是单继承，很不灵活</p></li></ol><p>接口的缺点：但是如果我们使用接口的话，很多类都要去实现这个接口，可能有很多重复的实现。没办法复用</p><p>此时我们就可以使用组合的方式，先抽象出一个接口/抽象类(例如Flyable接口)，然后让一个类去继承/实现它（FlyAbility 类实现了Flyable接口），我们通过在燕子（会飞的鸟）中通过组合的方式来调用FlyAbility.fly()的方式，采用组合的方式这样我们既避免了继承，又可以不用实现接口去重复写相应的实现。</p><h2 id="设计模式总览"><a href="#设计模式总览" class="headerlink" title="设计模式总览"></a>设计模式总览</h2><img src="https://cdn.jsdelivr.net/gh/yourFrank/pic@main/pic/image-20210928195127084.png" alt="image-20210928195127084" style="zoom:50%;" /><h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><img src="https://cdn.jsdelivr.net/gh/yourFrank/pic@main/pic/image-20210925142958029.png" alt="image-20210925142958029" style="zoom:60%;" /><p>当我们制作一个功能时：</p><ol><li>首先需要定义一个类：这就对应图中的<strong>组件定义</strong>（可以在<strong>结构型模式</strong>中找哪种模式适合我们定义一个类）</li><li>定义好类之后，我们需要创建对象：对应图<strong>组件的创建</strong>（在<strong>创建型模式</strong>中找）</li><li>接下来对象的使用：对应图<strong>组件的服役</strong>（<strong>行为型模式</strong>中找）</li><li>java会自动帮我们回收对象，此时对应组件的销毁。</li></ol><h2 id="设计的7大原则"><a href="#设计的7大原则" class="headerlink" title="设计的7大原则"></a>设计的7大原则</h2><p>经典设计原则包括，<strong>SOLID</strong>、KISS、YAGNI、DRY、LOD 等</p><p>不一定要遵循所有，需要根据实际情况来实行</p><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则(SRP)"></a>单一职责原则(SRP)</h3><p>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</p><blockquote><p>每个类只负责自己的事情，而不是定义一个超级大类，所有事情都调用这个类的方法 </p></blockquote><h3 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则(OCP)"></a>开闭原则(OCP)</h3><p>软件实体应当对扩展开放，对修改关闭</p><blockquote><p>当我们需要一个新的功能时，扩展新类而不是在原类上修改。</p><p>遇到需要扩展的，应该看能否先抽象出相应的接口，然后让新的类去实现相应的接口，而不是直接在类原逻辑中修改代码</p></blockquote><h3 id="里式替换原则-LSP"><a href="#里式替换原则-LSP" class="headerlink" title="里式替换原则(LSP)"></a>里式替换原则(LSP)</h3><p>子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><blockquote><ul><li>继承父类而不是去改变父类，子类继承父类的功能，而不去修改原有的方 法。</li><li>应该在父类提供扩展的方法上修改 。这样可以保证了在其他地方调用B的时候，同时可以替换为B的父类，逻辑不会改变</li></ul></blockquote><p>违背里式替换原则：</p><ol><li>子类违背父类声明要实现的功能</li></ol><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><ol start="2"><li>子类违背父类对输入、输出、异常的约定</li></ol><ul><li><p>在父类中，某个函数约定：运行出错的时候返回 null；获取数据为空的时候返回空集合（empty collection）。而子类重载函数之后，实现变了，运行出错返回异常（exception），获取不到数据返回 null。那子类的设计就违背里式替换原则。</p></li><li><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p></li><li><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p></li></ul><ol start="3"><li>子类违背父类注释中所罗列的任何特殊说明</li></ol><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则(ISP)"></a>接口隔离原则(ISP)</h3><p>一个类对另一个类的依赖应该建立在最小的接口上</p><blockquote><p>各个类建立自己的专用接口，而不是建立万能接口 </p></blockquote><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则(DIP)"></a>依赖倒置原则(DIP)</h3><h4 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h4><ol><li><p>这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了框架。</p></li><li><p>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p></li></ol><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。（参数一般相应的接口类型，我们可以通过多态传入相应的实现类）</p><h4 id="依赖注入框架"><a href="#依赖注入框架" class="headerlink" title="依赖注入框架"></a>依赖注入框架</h4><ol><li><p>虽然我们采取了依赖注入之后在实现类中不用new对象，但是我们在外部还是需要new对象来传入，当类多了我们进行类的创建和依赖注入会很复杂</p></li><li><p>使用依赖注入框架我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期。（比如spring一个@Autowired注解就可以帮我们将对象通过依赖注入的方式装载到另一个类中，不需要我们手动去new对象）</p></li></ol><h4 id="依赖反转原则"><a href="#依赖反转原则" class="headerlink" title="依赖反转原则"></a>依赖反转原则</h4><p>高层模块和低层模块应该通过抽象来相互依赖。也就是：面向接口编程，而不是面向实现类编程</p><blockquote><p>我们要调用实现类的接口，而不是直接使用实现类</p><p>(例如Controller中注册使用Service接口，Service中使用Dao接口, 这样无论Dao底层使用Mybatis还是Hibernate实现类操作数据库都不影响上层的访问)</p></blockquote><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>最少知识原则，只与你的直接朋友交谈，不跟“陌生人”说话</p><blockquote><ul><li>无需直接交互的两个类，如果需要交互，使用中间者</li><li>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低</li></ul></blockquote><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</p><blockquote><p>优先组合，其次继承</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文件</title>
      <link href="/post/c63a7203.html"/>
      <url>/post/c63a7203.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="note simple"><p>默认 提示块标籤</p></div><div class="note default simple"><p>default 提示块标籤</p></div><div class="note info modern"><p>info 提示块标籤</p></div><p>查看答案</p><div class="hide-block"><button type="button" class="hide-button button--animated" style="">查看答案    </button><div class="hide-content"><p>傻子，怎么可能有答案</p></div></div><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p><p>啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊</p>]]></content>
      
      
      <categories>
          
          <category> 第二个分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试文件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
